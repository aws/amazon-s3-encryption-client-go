// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package internal

import (
	"crypto/subtle"
	"encoding/binary"
	"fmt"
	"github.com/aws/amazon-s3-encryption-client-go/v4/algorithms"
	"crypto/hkdf"
)

const (
	// Key derivation constants
	DeriveKeyInfo = "DERIVEKEY"
	CommitKeyInfo = "COMMITKEY"
)

// KeyDerivationResult holds the results of HKDF key derivation
type KeyDerivationResult struct {
	DerivedEncryptionKey []byte
	CommitKey            []byte
}

func DeriveKeys(plaintextDataKey []byte, messageID []byte, algorithmSuiteID int, storedKeyCommitment []byte) (*KeyDerivationResult, error) {
	// Validate input parameters
	if len(plaintextDataKey) == 0 {
		return nil, fmt.Errorf("plaintext data key cannot be empty")
	}
	if len(messageID) == 0 {
		return nil, fmt.Errorf("message ID cannot be empty")
	}

	// Get algorithm suite to determine key lengths and other properties
	algSuite, err := algorithms.GetAlgorithmSuiteByID(algorithmSuiteID)
	if err != nil {
		return nil, fmt.Errorf("unable to get algorithm suite by ID: %v", err)
	}

	// Convert algorithm suite ID to bytes (big-endian)
	algorithmSuiteIDBytes := make([]byte, 2)
	binary.BigEndian.PutUint16(algorithmSuiteIDBytes, uint16(algorithmSuiteID))

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The hash function MUST be specified by the algorithm suite commitment settings.
	hashFunc := algSuite.KDFHashAlgorithm()
	if hashFunc == nil || !algSuite.IsCommitting() {
		return nil, fmt.Errorf("algorithm suite does not support key derivation: 0x%04x", algorithmSuiteID)
	}

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The input keying material MUST be the plaintext data key (PDK) generated by the key provider.
	inputKeyMaterial := plaintextDataKey

	// Get expected key lengths from algorithm suite
	expectedDataKeyLength := algSuite.DataKeyLengthBytes()
	expectedCommitKeyLength := algSuite.CommitmentLengthBytes()

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//# - The length of the input keying material MUST equal the key derivation input length specified by the algorithm suite commit key derivation setting.
	if len(inputKeyMaterial) != expectedDataKeyLength {
		return nil, fmt.Errorf("plaintext data key length must be %d bytes, got %d", expectedDataKeyLength, len(inputKeyMaterial))
	}

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//# - The salt MUST be the Message ID with the length defined in the algorithm suite.
	salt := messageID
	expectedSaltLength := algSuite.IVLengthBytes()
	if len(salt) != expectedSaltLength {
		return nil, fmt.Errorf("message ID length must be %d bytes, got %d", expectedSaltLength, len(salt))
	}

	// Extract step
	extractPRK, err := hkdf.Extract(hashFunc, inputKeyMaterial, salt)
	if err != nil {
		return nil, fmt.Errorf("hkdf extract failed: %w", err)
	}
	if len(extractPRK) == 0 {
		return nil, fmt.Errorf("hkdf extract failed: extractPRK is empty")
	}

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The input info MUST be a concatenation of the algorithm suite ID as bytes followed by the string COMMITKEY as UTF8 encoded bytes.
	commitKeyInfo := append(algorithmSuiteIDBytes, []byte(CommitKeyInfo)...)
	
	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The CK input pseudorandom key MUST be the output from the extract step.
	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//# - The length of the output keying material MUST equal the commit key length specified by the supported algorithm suites.
	derivedCommitKey, err := hkdf.Expand(hashFunc, extractPRK, string(commitKeyInfo), expectedCommitKeyLength)
	if err != nil {
		return nil, fmt.Errorf("failed to derive commit key: %w", err)
	}
	if len(derivedCommitKey) != expectedCommitKeyLength {
		return nil, fmt.Errorf("commit key length must be %d bytes, got %d", expectedCommitKeyLength, len(derivedCommitKey))
	}

	// First, check commitment value; then, derive encryption key
	//= ../specification/s3-encryption/decryption.md#decrypting-with-commitment
	//= type=implication
	//# When using an algorithm suite which supports key commitment, the client MUST verify the key commitment values match before deriving the [derived encryption key](./key-derivation.md#hkdf-operation).

	if storedKeyCommitment != nil {
		//= ../specification/s3-encryption/decryption.md#decrypting-with-commitment
		//# When using an algorithm suite which supports key commitment, the client MUST verify that the [derived key commitment](./key-derivation.md#hkdf-operation) contains the same bytes as the stored key commitment retrieved from the stored object's metadata.
		//= ../specification/s3-encryption/decryption.md#decrypting-with-commitment
		//= type=implication
		//# When using an algorithm suite which supports key commitment, the verification of the derived key commitment value MUST be done in constant time.
		if subtle.ConstantTimeCompare(derivedCommitKey, storedKeyCommitment) != 1 {
			//= ../specification/s3-encryption/decryption.md#decrypting-with-commitment
			//# When using an algorithm suite which supports key commitment, the client MUST throw an exception when the derived key commitment value and stored key commitment value do not match.
			return nil, fmt.Errorf("derived key commitment value does not match value stored on encrypted message")
		}
	}

	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The input info MUST be a concatenation of the algorithm suite ID as bytes followed by the string DERIVEKEY as UTF8 encoded bytes.
	encryptionKeyInfo := append(algorithmSuiteIDBytes, []byte(DeriveKeyInfo)...)
	
	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//= type=implication
	//# - The DEK input pseudorandom key MUST be the output from the extract step.
	//= ../specification/s3-encryption/key-derivation.md#hkdf-operation
	//# - The length of the output keying material MUST equal the encryption key length specified by the algorithm suite encryption settings.
	derivedEncryptionKey, err := hkdf.Expand(hashFunc, extractPRK, string(encryptionKeyInfo), expectedDataKeyLength)
	if err != nil {
		return nil, fmt.Errorf("failed to derive encryption key: %w", err)
	}
	if len(derivedEncryptionKey) != expectedDataKeyLength {
		return nil, fmt.Errorf("encryption key length must be %d bytes, got %d", expectedDataKeyLength, len(derivedEncryptionKey))
	}

	return &KeyDerivationResult{
		DerivedEncryptionKey: derivedEncryptionKey,
		CommitKey:            derivedCommitKey,
	}, nil
}
